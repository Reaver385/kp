#!/bin/bash
#
# Copyright 2012 "Korora Project" <dev@kororaproject.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

#
# BUILD
#
OPT_VERBOSE=
OPT_MOCK_CLEAN=

OPT_DIST=fedora
OPT_RELEASEVER=17
OPT_BASEARCH=x86_64


#
# FUNCTIONS
#
function usage {
  _EXIT_VAL=${1:-0}

  cat << EOF
  Usage: $0 [-vc]

  Options:
    -a   Set base architecture
    -d   Set distribution
    -r   Set release version
    -x   Initialise mock to a clean state.
    -v   Show verbose output
    -?   Show this usage
    -V   Show version

  Long Options:
    --arch          Same as -a
    --distribution  Same as -d
    --releasever    Same as -r
    --clean         Same as -x
    --verbose       Same as -v
    --help          Same as -?
    --version       Same as -V

EOF

  exit ${_EXIT_VAL};
}

#
# PARSE COMMAND LINE
#

function parse_args {
  CMD_LINE=$(getopt -n$0 -u --longoptions="arch distribution releasever clean verbose version help" "a d r x v V ?" $@)
  [ ${?} -ne 0 ] && usage 1

  set -- ${CMD_LINE}

  while [ $# -gt 0 ]
  do
    case "$1" in
      -a|--arch)
        ;;
      -d|--distribition)
        ;;
      -r|--releasever)
        ;;
      -x|--clean)
        OPT_MOCK_CLEAN=1
        ;;
      -v|--verbose)
        OPT_VERBOSE=1
        ;;
      -V|--version)
        version 0
        ;;
      -h|--help)
        usage 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        usage 1
        ;;
      *)
        break
    esac
    shift
  done

  # remaining arguments are packages
  PACKAGES=""
  if [ $# -eq 0 ]
  then
    echo "Building all packages ..."
  else
    while [ $# -gt 0 ]
    do
      PACKAGES="${PACKAGES} $1"
      shift
    done
  fi

  echo "PACKAGES INIT = $PACKAGES"
}

function check_upstream {
  echo "check_upstream"
  if [ -d ${WORKING_PACKAGES_DIR}/$KP_NAME/upstream ]
  then
    echo "do git rebase stuff"
    echo "copy patches to  ${WORKING_PACKAGES_DIR}/$KP_NAME/build/sources/"
  fi
}

function initialise_mock {
  _debug "Initialising mock build environment.."
  mock --root ${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH} --clean
  mock --root ${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH} --init
}

function generate_spec {
  _pushd ${WORKING_PACKAGES_DIR}/$KP_NAME/build/
  echo -e "\n\ngenerate_spec from template, sed stuff, etc"
  _popd
}

function gather_source {
  _debug "Gathering source..."
  case ${KP_UPSTREAM_SRC_TYPE} in
    binary)
#      _pushd ${WORKING_PACKAGES_DIR}/$KP_NAME/build/
      spectool -g $KP_NAME.spec -C "${WORKING_PACKAGES_DIR}/$KP_NAME/build/"
#      _popd
      ;;
    git)
      ;;
    local)
      # is alwasy a git repo
      _pushd "${WORKING_PACKAGES_DIR}/${KP_NAME}/upstream"

      _debug "Creating (local) tarball source ..."
      git archive --format=tar.gz --prefix="${KP_NAME}-${KP_VERSION}/" -o "${WORKING_PACKAGES_DIR}/${KP_NAME}/build/${KP_NAME}-${KP_VERSION}.tar.gz" HEAD

      _popd
      ;;
  esac
  #am i local repo?
  #  git archive sha hash
  #am I spec file tarball?
  #do I have any patches
  #echo "(we might have patches from upstream, or patches from git repo, need source tarball)"
}

function mock_build {
  _pushd ${WORKING_PACKAGES_DIR}/$KP_NAME/build/

  [ -z ${OPT_VERBOSE} ] &&  _VERBOSE="-q" || _VERBOSE="-v"

  _debug "Building source package, please wait.."
  mock ${_VERBOSE} --root ${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH} --buildsrpm --spec $KP_NAME.spec --sources . || _error "Could not create source package, skipping package"

  _debug "Building package, please wait.."
  # --no-clean because we have srpm in there, else need to copy out (and build should be clean anyway)
  mock ${_VERBOSE} --no-clean --root ${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH} --rebuild /var/lib/mock/${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH}/result/$(basename $(grep ^Wrote /var/lib/mock/${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH}/result/build.log |grep src.rpm |awk {'print $2'} |uniq)) || _error "Could not build package, skipping"
  _popd

  _pushd "${WORKING_REPOSITORY_DIR}"
  _debug "Copying packages to: ${WORKING_REPOSITORY_DIR}"
  for x in $(grep ^Wrote /var/lib/mock/${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH}/result/build.log |awk {'print $2'} |uniq)
  do
    x=$(basename $x)
    cp -f /var/lib/mock/${OPT_DIST}-${OPT_RELEASEVER}-${OPT_BASEARCH}/result/$(basename $x) .
  done
  _popd
}

#
# MAIN
#

function main {
  #create rpmbuild env
#  rpmdev-setuptree || _error "Could not create rpmbuild environment, exiting" ; exit 1

  if [ ! -z ${OPT_MOCK_CLEAN} ]
  then
    initialise_mock
  fi

  # load the configuration
  for F in $(list_config_available)
  do
    load_config ${F}
    [ ${?} -ne 0 ] && continue

    # skip if this is not requested
    if [ -n "${PACKAGES}" ]
    then
      echo ${PACKAGES} | grep -q ${KP_NAME} || continue
    fi

    echo "KP_NAME = $KP_NAME"
    echo "KP_VERSION = $KP_VERSION"
    echo "KP_URL = $KP_URL"
    echo "KP_UPSTREAM_SRC_TYPE = $KP_UPSTREAM_SRC_TYPE"
    echo "KP_UPSTREAM_SRC_URL = $KP_UPSTREAM_SRC_URL"
    echo "BUILD_SPEC = $BUILD_SPEC"
    echo "KP_RELEASE_GIT_COMMIT = $KP_RELEASE_GIT_COMMIT"

    echo ${CMD_LINE}

    if [ ! -d "${WORKING_PACKAGES_DIR}/$KP_NAME" ]
    then
      _error "No checkout done, skipping"
      continue
    fi

    [ "${KP_UPSTREAM_SRC_TYPE}" == "upstream" ] && check_upstream ${F}

    generate_spec ${F}
    gather_source ${F}
    mock_build ${F}
  done

  # rebuild the repository directory
  [ -z ${OPT_VERBOSE} ] &&  _VERBOSE= || _VERBOSE="-v"
  createrepo ${_VERBOSE} "${WORKING_REPOSITORY_DIR}"
}
